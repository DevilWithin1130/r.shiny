name: RenoPilot Web App CI/CD

on: 
  push:
    branches: [main]
    paths-ignore:
    - '.github/workflows/container-instance-ci-cd.yaml'
  pull_request:
    branches: [main]
    paths-ignore:
    - '.github/workflows/container-instance-ci-cd.yaml'
  workflow_dispatch:

jobs:
  test-app:
    runs-on: ubuntu-latest
    name: Test R Shiny App
    
    env:
      GITHUB_PAT: ${{ secrets.RENOPILOT_TOKEN }}
      R_KEEP_PKG_SOURCE: yes

    steps:
      - name: Checkout Code Base
        uses: actions/checkout@v3

      - name: Set up R Environment
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: release
          use-public-rspm: true

      - name: Install Dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: shinytest2

      - name: Define Environment Variables
        run: |
          echo Environment="Github" >> ~/.Renviron
          echo Driver="ODBC Driver 18 for SQL Server" >> ~/.Renviron
          echo Server="shiny.database.windows.net" >> ~/.Renviron
          echo Database="Shiny" >> ~/.Renviron
          echo UID="shiny" >> ~/.Renviron
          echo PWD="${{ secrets.DB_PASSWORD }}" >> ~/.Renviron
        shell: bash

      - name: Run Tests
        uses: rstudio/shinytest2/actions/test-app@v1
        with:
          path: "."

  deploy-infrastructure:
    needs: test-app
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@main

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Register Required Resource Providers
      uses: azure/cli@v1
      with:
        inlineScript: |
          echo "Registering Azure resource providers required for RenoPilot Web App infrastructure..."
          # These Microsoft namespaces are required Azure services for RenoPilot application
          # They cannot be renamed but are essential for our infrastructure
          az provider register --namespace Microsoft.Web
          az provider register --namespace Microsoft.ContainerRegistry
          az provider register --namespace Microsoft.Network
          
          echo "Waiting for RenoPilot required Azure service registrations to complete..."
          # Checking registration status for required providers
          az provider show -n Microsoft.Web --query registrationState
          az provider show -n Microsoft.ContainerRegistry --query registrationState
          az provider show -n Microsoft.Network --query registrationState
          
          # Verify registrations with timeout
          for provider in Microsoft.Web Microsoft.ContainerRegistry Microsoft.Network; do
            state=$(az provider show -n $provider --query registrationState -o tsv)
            echo "RenoPilot Azure dependency: $provider registration state: $state"
            if [ "$state" != "Registered" ]; then
              echo "Waiting for $provider to complete registration..."
              for i in {1..12}; do
                sleep 10
                state=$(az provider show -n $provider --query registrationState -o tsv)
                echo "$provider registration state: $state"
                if [ "$state" == "Registered" ]; then
                  break
                fi
                if [ $i -eq 12 ] && [ "$state" != "Registered" ]; then
                  echo "Warning: $provider registration taking longer than expected. Continuing anyway."
                fi
              done
            fi
          done

    - name: Clean Up Existing Infrastructure
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Check if Resource Group exists
          RG_EXISTS=$(az group exists --name RenoPilotWebAppRG)
          
          if [ "$RG_EXISTS" = "true" ]; then
            echo "Resource Group exists. Beginning cleanup of existing resources..."
            
            # 1. Clean up Web Apps
            echo "Cleaning up Web Apps..."
            WEBAPPS=$(az webapp list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$WEBAPPS" ]; then
              for WEBAPP in $WEBAPPS; do
                echo "Deleting Web App: $WEBAPP"
                az webapp delete --name $WEBAPP --resource-group RenoPilotWebAppRG --keep-empty-plan
              done
              # Wait for webapp deletion to complete
              sleep 30
            else
              echo "No Web Apps found to clean up."
            fi
            
            # 2. Clean up App Service Plans
            echo "Cleaning up App Service Plans..."
            APP_PLANS=$(az appservice plan list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$APP_PLANS" ]; then
              for PLAN in $APP_PLANS; do
                echo "Deleting App Service Plan: $PLAN"
                az appservice plan delete --name $PLAN --resource-group RenoPilotWebAppRG --yes
              done
              # Wait for app plan deletion to complete
              sleep 30
            else
              echo "No App Service Plans found to clean up."
            fi
            
            # 3. First remove NSG associations from subnets - FIX ERROR HERE
            echo "Removing NSG associations from subnets..."
            VNETS=$(az network vnet list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$VNETS" ]; then
              for VNET in $VNETS; do
                SUBNETS=$(az network vnet subnet list --resource-group RenoPilotWebAppRG --vnet-name $VNET --query "[].name" -o tsv)
                for SUBNET in $SUBNETS; do
                  echo "Removing NSG association from subnet: $SUBNET in VNet: $VNET"
                  # Check for existing NSG association first
                  NSG_ID=$(az network vnet subnet show --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --query "networkSecurityGroup.id" -o tsv 2>/dev/null || echo "")
                  RT_ID=$(az network vnet subnet show --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --query "routeTable.id" -o tsv 2>/dev/null || echo "")
                  
                  # Remove NSG association if it exists
                  if [ -n "$NSG_ID" ] && [ "$NSG_ID" != "null" ]; then
                    echo "Removing NSG association from subnet $SUBNET"
                    az network vnet subnet update --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --remove networkSecurityGroup || echo "Failed to remove NSG from subnet $SUBNET, continuing..."
                  else
                    echo "No NSG association found for subnet $SUBNET"
                  fi
                  
                  # Remove route table association if it exists
                  if [ -n "$RT_ID" ] && [ "$RT_ID" != "null" ]; then
                    echo "Removing route table association from subnet $SUBNET"
                    az network vnet subnet update --resource-group RenoPilotWebAppRG --vnet-name $VNET --name $SUBNET --remove routeTable || echo "Failed to remove route table from subnet $SUBNET, continuing..."
                  else
                    echo "No route table association found for subnet $SUBNET"
                  fi
                done
              done
              # Wait for association removal to complete
              sleep 15
            fi
            
            # 4. Now clean up Network Security Groups
            echo "Cleaning up Network Security Groups..."
            NSGS=$(az network nsg list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$NSGS" ]; then
              for NSG in $NSGS; do
                echo "Deleting NSG: $NSG"
                az network nsg delete --name $NSG --resource-group RenoPilotWebAppRG
              done
              # Wait for NSG deletion to complete
              sleep 15
            else
              echo "No NSGs found to clean up."
            fi
            
            # 5. Clean up Firewalls
            echo "Cleaning up Firewalls..."
            FIREWALLS=$(az network firewall list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$FIREWALLS" ]; then
              for FIREWALL in $FIREWALLS; do
                echo "Deleting Firewall: $FIREWALL"
                az network firewall delete --name $FIREWALL --resource-group RenoPilotWebAppRG
              done
              # Wait for firewall deletion to complete
              sleep 30
            else
              echo "No Firewalls found to clean up."
            fi
            
            # 6. Clean up Subnets (required before VNet cleanup)
            echo "Cleaning up VNets and Subnets..."
            VNETS=$(az network vnet list --resource-group RenoPilotWebAppRG --query "[].name" -o tsv)
            if [ -n "$VNETS" ]; then
              for VNET in $VNETS; do
                # Get subnets in this VNet
                SUBNETS=$(az network vnet subnet list --resource-group RenoPilotWebAppRG --vnet-name $VNET --query "[].name" -o tsv)
                for SUBNET in $SUBNETS; do
                  echo "Deleting Subnet: $SUBNET in VNet: $VNET"
                  az network vnet subnet delete --name $SUBNET --vnet-name $VNET --resource-group RenoPilotWebAppRG
                done
                # Delete VNet after subnets
                echo "Deleting VNet: $VNET"
                az network vnet delete --name $VNET --resource-group RenoPilotWebAppRG
              done
              # Wait for VNet deletion to complete
              sleep 30
            else
              echo "No VNets found to clean up."
            fi
            
            echo "Clean-up completed."
          else
            echo "Resource Group does not exist. No cleanup needed."
          fi

          # Set Australian and Asian regions to use
          REGIONS=("australiaeast" "australiasoutheast" "australiacentral" "australiacentral2" "eastasia" "southeastasia")
          echo "Will create resources in Australian or Asian regions: ${REGIONS[*]}"
    
    - name: Check Existing Infrastructure
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Try a list of regions in order of preference - Australian and Asian regions
          REGIONS=("australiaeast" "australiasoutheast" "eastasia" "southeastasia" "australiacentral" "australiacentral2")
          LOCATION=""
          
          # Check if Resource Group exists
          RG_EXISTS=$(az group exists --name RenoPilotWebAppRG)
          
          if [ "$RG_EXISTS" = "true" ]; then
            echo "Resource Group already exists."
            
            # If resource group exists, check if we already have resources deployed
            # Try to find an existing App Service Plan in the resource group
            EXISTING_PLANS=$(az appservice plan list --resource-group RenoPilotWebAppRG --query "[].{name:name, location:location}" -o json)
            
            # If we have an existing plan, use its location
            if [ -n "$EXISTING_PLANS" ] && [ "$EXISTING_PLANS" != "[]" ]; then
              # Use the location of the first plan found
              LOCATION=$(echo $EXISTING_PLANS | jq -r '.[0].location')
              echo "Using existing resources in location: $LOCATION"
            else
              echo "Resource Group exists but no App Service Plan found. Searching for available region..."
              # Continue with region search as no existing App Service Plans found
              
              # Try each region with different SKUs
              SKUS=("F1" "B1" "S1" "P1v2")
              
              # Try Australian and Asian regions
              echo "Checking Australian and Asian regions..."
              for region in "${REGIONS[@]}"; do
                for SKU in "${SKUS[@]}"; do
                  echo "Checking quota for region $region with SKU $SKU..."
                  
                  # Capture detailed error output
                  ERROR_OUTPUT=$(az appservice plan create \
                    --name "temp-quota-check-$SKU" \
                    --resource-group RenoPilotWebAppRG \
                    --is-linux \
                    --sku $SKU \
                    --location $region 2>&1)
                  
                  if [ $? -eq 0 ]; then
                    echo "Found region with quota: $region for SKU: $SKU"
                    LOCATION=$region
                    SELECTED_SKU=$SKU
                    
                    # Clean up the temporary plan
                    echo "Cleaning up temporary app service plan..."
                    az appservice plan delete --name "temp-quota-check-$SKU" --resource-group RenoPilotWebAppRG --yes
                    
                    # Store selected SKU
                    echo "APP_SKU=$SELECTED_SKU" >> $GITHUB_ENV
                    break 2
                  else
                    echo "Region $region with SKU $SKU has issues. Error details:"
                    echo "$ERROR_OUTPUT"
                  fi
                done
              done
            fi
          else
            echo "Resource Group does not exist. Will create in an available region."
            # Create resource group in a region where quota is available
            
            # Try each region with different SKUs
            SKUS=("F1" "B1" "S1" "P1v2")
            
            # Try Australian and Asian regions
            echo "Checking Australian and Asian regions..."
            for region in "${REGIONS[@]}"; do
              # Create resource group temporarily for testing
              echo "Creating temporary resource group in $region..."
              az group create --name RenoPilotWebAppRG --location $region
              
              for SKU in "${SKUS[@]}"; do
                echo "Checking quota for region $region with SKU $SKU..."
                
                # Capture detailed error output
                ERROR_OUTPUT=$(az appservice plan create \
                  --name "temp-quota-check-$SKU" \
                  --resource-group RenoPilotWebAppRG \
                  --is-linux \
                  --sku $SKU \
                  --location $region 2>&1)
                
                if [ $? -eq 0 ]; then
                  echo "Found region with quota: $region for SKU: $SKU"
                  LOCATION=$region
                  SELECTED_SKU=$SKU
                  
                  # Clean up the temporary plan
                  echo "Cleaning up temporary app service plan..."
                  az appservice plan delete --name "temp-quota-check-$SKU" --resource-group RenoPilotWebAppRG --yes
                  
                  # Store selected SKU
                  echo "APP_SKU=$SELECTED_SKU" >> $GITHUB_ENV
                  break 2
                else
                  echo "Region $region with SKU $SKU has issues. Error details:"
                  echo "$ERROR_OUTPUT"
                fi
              done
            done
          fi
          
          # If no region with quota was found
          if [ -z "$LOCATION" ]; then
            echo "ERROR: Could not find any Australian or Asian region with available App Service Plan quota."
            echo "Please request a quota increase through the Azure portal or contact Azure support."
            echo "Alternatively, check the subscription limits and make sure the service principal has appropriate permissions."
            
            # Print subscription information for debugging
            echo "Subscription information:"
            az account show
            
            # List all regions and their status
            echo "Available regions for subscription:"
            az account list-locations --query "[].{name:name, displayName:displayName, regionType:regionType, physicalLocation:metadata.physicalLocation}" -o table
            
            exit 1
          fi
          
          echo "Using location: $LOCATION"
          
          # Store location for use in later steps
          echo "AZURE_LOCATION=$LOCATION" >> $GITHUB_ENV
          
          # Generate a timestamp for unique resource names
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV

    - name: Create VPC and Subnets
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          
          # Create VNet with region-specific name
          VNET_NAME="renopilot-vpc-$LOCATION"
          
          # Check if VNet already exists
          if az network vnet show --name $VNET_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "VNet '$VNET_NAME' already exists. Skipping creation."
          else
            echo "Creating VNet '$VNET_NAME'..."
            az network vnet create \
              --name $VNET_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION \
              --address-prefix 10.1.0.0/16
            
            # Add delay to ensure VNet is fully provisioned
            sleep 10
          fi
          
          # Store VNet name for later steps
          echo "VNET_NAME=$VNET_NAME" >> $GITHUB_ENV
          
          # Public subnet with region-specific name
          PUBLIC_SUBNET_NAME="WebAppPublicSubnet-$LOCATION"
          
          # Check if public subnet already exists
          if az network vnet subnet show --name $PUBLIC_SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Public Subnet '$PUBLIC_SUBNET_NAME' already exists. Skipping creation."
          else
            echo "Creating Public Subnet '$PUBLIC_SUBNET_NAME'..."
            az network vnet subnet create \
              --name $PUBLIC_SUBNET_NAME \
              --vnet-name $VNET_NAME \
              --resource-group RenoPilotWebAppRG \
              --address-prefix 10.1.1.0/24 \
              --delegations Microsoft.Web/serverFarms \
              --service-endpoints Microsoft.Web
            
            # Add delay to ensure subnet is fully provisioned
            sleep 10
          fi
          
          # Store subnet name for later steps
          echo "PUBLIC_SUBNET_NAME=$PUBLIC_SUBNET_NAME" >> $GITHUB_ENV
          
          # Private subnet with region-specific name
          PRIVATE_SUBNET_NAME="WebAppPrivateSubnet-$LOCATION"
          
          # Check if private subnet already exists
          if az network vnet subnet show --name $PRIVATE_SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Private Subnet '$PRIVATE_SUBNET_NAME' already exists. Skipping creation."
          else
            echo "Creating Private Subnet '$PRIVATE_SUBNET_NAME'..."
            az network vnet subnet create \
              --name $PRIVATE_SUBNET_NAME \
              --vnet-name $VNET_NAME \
              --resource-group RenoPilotWebAppRG \
              --address-prefix 10.1.2.0/24
            
            # Add delay to ensure subnet is fully provisioned
            sleep 10
          fi
          
          # Store subnet name for later steps
          echo "PRIVATE_SUBNET_NAME=$PRIVATE_SUBNET_NAME" >> $GITHUB_ENV

    - name: Deploy Network Security Groups
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          # Create NSG with region-specific name
          NSG_NAME="webapp-nsg-$LOCATION"
          
          # Check if NSG already exists
          if az network nsg show --name $NSG_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Network Security Group '$NSG_NAME' already exists. Skipping creation."
          else
            echo "Creating Network Security Group '$NSG_NAME'..."
            az network nsg create \
              --name $NSG_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
            
            # Add explicit inbound rule for Shiny Server port 3838
            echo "Adding inbound security rule for Shiny port 3838..."
            az network nsg rule create \
              --name AllowShinyInbound \
              --nsg-name $NSG_NAME \
              --resource-group RenoPilotWebAppRG \
              --priority 100 \
              --direction Inbound \
              --access Allow \
              --protocol Tcp \
              --source-address-prefixes "*" \
              --source-port-ranges "*" \
              --destination-address-prefixes "*" \
              --destination-port-ranges 3838 \
              --description "Allow Shiny Server traffic on port 3838"
            
            # Add HTTP/HTTPS inbound rules for web traffic
            echo "Adding inbound security rule for HTTP/HTTPS..."
            az network nsg rule create \
              --name AllowHTTPInbound \
              --nsg-name $NSG_NAME \
              --resource-group RenoPilotWebAppRG \
              --priority 200 \
              --direction Inbound \
              --access Allow \
              --protocol Tcp \
              --source-address-prefixes "*" \
              --source-port-ranges "*" \
              --destination-address-prefixes "*" \
              --destination-port-ranges 80 443 \
              --description "Allow HTTP/HTTPS traffic"
          fi
          
          # Store NSG name for later steps
          echo "NSG_NAME=$NSG_NAME" >> $GITHUB_ENV
          
          # Apply NSG to the subnet
          echo "Applying NSG to subnet..."
          az network vnet subnet update \
            --name ${{ env.PUBLIC_SUBNET_NAME }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --resource-group RenoPilotWebAppRG \
            --network-security-group $NSG_NAME

    - name: Deploy Firewalls
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          echo "Creating Firewalls..."
          
          # Create Public Firewall with region-specific name
          PUBLIC_FW_NAME="webapp-publicfw-$LOCATION"
          
          # Check if public firewall already exists
          if az network firewall show --name $PUBLIC_FW_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Public Firewall '$PUBLIC_FW_NAME' already exists. Skipping creation."
          else
            echo "Creating Public Firewall '$PUBLIC_FW_NAME'..."
            az network firewall create \
              --name $PUBLIC_FW_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
          fi
          
          # Store firewall name for later steps
          echo "PUBLIC_FW_NAME=$PUBLIC_FW_NAME" >> $GITHUB_ENV
          
          # Create Private Firewall with region-specific name
          PRIVATE_FW_NAME="webapp-privatefw-$LOCATION"
          
          # Check if private firewall already exists
          if az network firewall show --name $PRIVATE_FW_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Private Firewall '$PRIVATE_FW_NAME' already exists. Skipping creation."
          else
            echo "Creating Private Firewall '$PRIVATE_FW_NAME'..."
            az network firewall create \
              --name $PRIVATE_FW_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
          fi
          
          # Store firewall name for later steps
          echo "PRIVATE_FW_NAME=$PRIVATE_FW_NAME" >> $GITHUB_ENV
          
          # Create a route table for the subnet with region-specific name
          ROUTE_TABLE_NAME="webapp-routes-$LOCATION"
          
          # Check if route table already exists
          if az network route-table show --name $ROUTE_TABLE_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Route Table '$ROUTE_TABLE_NAME' already exists. Skipping creation."
          else
            echo "Creating route table '$ROUTE_TABLE_NAME'..."
            az network route-table create \
              --name $ROUTE_TABLE_NAME \
              --resource-group RenoPilotWebAppRG \
              --location $LOCATION
          fi
          
          # Store route table name for later steps
          echo "ROUTE_TABLE_NAME=$ROUTE_TABLE_NAME" >> $GITHUB_ENV
          
          # Add the route table to the subnet
          echo "Applying route table to subnet..."
          az network vnet subnet update \
            --name ${{ env.PUBLIC_SUBNET_NAME }} \
            --vnet-name ${{ env.VNET_NAME }} \
            --resource-group RenoPilotWebAppRG \
            --route-table $ROUTE_TABLE_NAME

    - name: Deploy Container Registry
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          # Use a unique ACR name that includes location (ACR names must be globally unique)
          ACR_NAME="renopilot${LOCATION}reg"
          
          # Check if ACR already exists
          if az acr show --name $ACR_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Container Registry '$ACR_NAME' already exists. Skipping creation."
          else
            echo "Creating Container Registry '$ACR_NAME'..."
            az acr create \
              --resource-group RenoPilotWebAppRG \
              --name $ACR_NAME \
              --sku Standard \
              --location $LOCATION \
              --admin-enabled true
          fi
          
          # Retrieve and store registry credentials securely in GitHub environment
          ACR_LOGIN_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)
          ACR_USERNAME=$(az acr credential show -n $ACR_NAME --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show -n $ACR_NAME --query "passwords[0].value" -o tsv)
          
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
          echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV
          # Add mask to hide sensitive output in logs
          echo "::add-mask::$ACR_PASSWORD"

    - name: Check if Docker image exists
      id: check-image
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          ACR_NAME="renopilot${LOCATION}reg"
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_NAME="renopilot-fenceapp"
          
          # Check if the image with the specific tag already exists in ACR
          echo "Checking if image $IMAGE_NAME:$IMAGE_TAG already exists in ACR..."
          
          # Using az acr repository show to check if image exists
          if az acr repository show --name $ACR_NAME --image "$IMAGE_NAME:$IMAGE_TAG" &>/dev/null; then
            echo "Image $IMAGE_NAME:$IMAGE_TAG already exists in ACR. Skipping build and push."
            echo "IMAGE_EXISTS=true" >> $GITHUB_ENV
            echo "exists=true" >> $GITHUB_OUTPUT  # Updated to current GitHub Actions syntax
          else
            echo "Image $IMAGE_NAME:$IMAGE_TAG does not exist in ACR. Will build and push."
            echo "IMAGE_EXISTS=false" >> $GITHUB_ENV
            echo "exists=false" >> $GITHUB_OUTPUT  # Updated to current GitHub Actions syntax
          fi

    - name: Build and push image
      if: env.IMAGE_EXISTS != 'true'
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ env.ACR_USERNAME }}
        password: ${{ env.ACR_PASSWORD }}
    - run: |
        if [ "${{ env.IMAGE_EXISTS }}" != "true" ]; then
          echo "Building and pushing new Docker image..."
          docker build -f containerResources/dockerfile . -t ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }}          
          docker push ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }}
        else
          echo "Skipping Docker build and push as image already exists."
        fi

    - name: Create App Service Plan
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Create App Service Plan with region-specific name
          LOCATION="${{ env.AZURE_LOCATION }}"
          APP_PLAN_NAME="renopilot-plan-$LOCATION"
          # Use the SKU we already confirmed works
          SKU="${{ env.APP_SKU }}"
          
          # Check if App Service Plan already exists
          if az appservice plan show --name $APP_PLAN_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "App Service Plan '$APP_PLAN_NAME' already exists. Skipping creation."
          else
            echo "Creating App Service Plan '$APP_PLAN_NAME' with SKU $SKU..."
            
            # If we don't have a working SKU from previous step, try different ones
            if [ -z "$SKU" ]; then
              SKUS=("B1" "S1" "P1v2" "F1")
            else
              # Only try the SKU we found that works
              SKUS=("$SKU")
            fi
            
            MAX_RETRIES=3
            
            # First try with different SKUs
            for SKU in "${SKUS[@]}"; do
              echo "Attempting to create App Service Plan with SKU: $SKU"
              
              for ((i=1; i<=MAX_RETRIES; i++)); do
                echo "Attempt $i of $MAX_RETRIES to create App Service Plan with SKU $SKU..."
                
                # Capture detailed error output
                ERROR_OUTPUT=$(az appservice plan create \
                  --name $APP_PLAN_NAME \
                  --resource-group RenoPilotWebAppRG \
                  --is-linux \
                  --sku $SKU \
                  --location $LOCATION 2>&1)
                
                if [ $? -eq 0 ]; then
                  echo "App Service Plan created successfully with SKU $SKU!"
                  echo "APP_PLAN_NAME=$APP_PLAN_NAME" >> $GITHUB_ENV
                  echo "APP_SKU=$SKU" >> $GITHUB_ENV
                  echo "APP_PLAN_SUCCESS=true" >> $GITHUB_ENV
                  break 2  # Break out of both loops
                else
                  echo "Failed to create App Service Plan with SKU $SKU."
                  echo "Error details:"
                  echo "$ERROR_OUTPUT"
                  if [ $i -lt $MAX_RETRIES ]; then
                    # Exponential backoff - wait longer with each retry
                    SLEEP_TIME=$((20 * i))
                    echo "Waiting for $SLEEP_TIME seconds before next attempt..."
                    sleep $SLEEP_TIME
                  fi
                fi
              done
            done
            
            # Check if we succeeded with any SKU
            if ! az appservice plan show --name $APP_PLAN_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
              echo "ERROR: All attempts to create App Service Plan failed."
              echo "Please check your Azure subscription quota limits and try again."
              exit 1
            fi
          fi
          
          # Store App Service Plan name for later steps
          echo "APP_PLAN_NAME=$APP_PLAN_NAME" >> $GITHUB_ENV

    - name: Create Web App and Configure
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          # Create Web App with region-specific name
          WEBAPP_NAME="renopilot-webapp-$LOCATION"
          
          # Check if Web App already exists
          if az webapp show --name $WEBAPP_NAME --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Web App '$WEBAPP_NAME' already exists. Skipping creation."
          else
            echo "Creating Web App '$WEBAPP_NAME'..."
            
            # Create the web app without the image (we'll deploy separately)
            az webapp create \
              --resource-group RenoPilotWebAppRG \
              --plan ${{ env.APP_PLAN_NAME }} \
              --name $WEBAPP_NAME \
              --deployment-container-image-name nginx \
              --runtime "DOCKER|nginx"
            echo "WEBAPP_NAME=$WEBAPP_NAME" >> $GITHUB_ENV
            
            # Add delay to ensure webapp is created
            sleep 15
            
            # Configure environment variables for the web app
            az webapp config appsettings set \
              --resource-group RenoPilotWebAppRG \
              --name $WEBAPP_NAME \
              --settings \
              DOCKER_ENV=true \
              DB_SERVER=shiny.database.windows.net \
              DB_NAME=Shiny \
              DB_USER=shiny \
              DB_DRIVER="ODBC Driver 18 for SQL Server" \
              DB_PORT=1433 \
              WEBSITES_PORT=3838 \
              DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          fi

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      id: deploy
      with:
        app-name: ${{ env.WEBAPP_NAME }}
        images: ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }}
        slot-name: 'production'
        
    - name: Verify Deployment Success
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Verify deployment status
          echo "Verifying deployment status..."
          DEPLOYMENT_STATUS=$(az webapp deployment container show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query properties.status -o tsv 2>/dev/null || echo "Unknown")
          
          if [[ "$DEPLOYMENT_STATUS" == "Success" ]]; then
            echo "Deployment completed successfully!"
          else
            echo "Checking container readiness..."
            # Wait for up to 5 minutes for the container to become ready
            for i in {1..10}; do
              CONTAINER_STATUS=$(az webapp show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query state -o tsv 2>/dev/null || echo "Unknown")
              if [[ "$CONTAINER_STATUS" == "Running" ]]; then
                echo "Container is now running!"
                break
              fi
              echo "Container status: $CONTAINER_STATUS. Waiting 30 seconds..."
              sleep 30
            done
          fi
          
          # Display the web app URL with proper protocol
          WEBAPP_URL=$(az webapp show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query "defaultHostName" -o tsv)
          echo "Web app deployed at: https://$WEBAPP_URL"
          echo "Shiny app should be accessible at: https://$WEBAPP_URL"
          
          # Add a message to make the URL clickable in GitHub Actions log
          echo "::notice::Web app deployed at https://$WEBAPP_URL"

    - name: Configure Container Settings
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Configure container settings after deployment
          echo "Configuring container settings after deployment..."
          az webapp config container set \
            --name ${{ env.WEBAPP_NAME }} \
            --resource-group RenoPilotWebAppRG \
            --docker-custom-image-name ${{ env.ACR_LOGIN_SERVER }}/renopilot-fenceapp:${{ github.sha }} \
            --docker-registry-server-url https://${{ env.ACR_LOGIN_SERVER }} \
            --docker-registry-server-user ${{ env.ACR_USERNAME }} \
            --docker-registry-server-password ${{ env.ACR_PASSWORD }} \
            --enable-app-service-storage false
          
          # Explicitly set port mapping
          echo "Setting port mapping to 3838..."
          az webapp config appsettings set \
            --resource-group RenoPilotWebAppRG \
            --name ${{ env.WEBAPP_NAME }} \
            --settings \
            WEBSITES_PORT=3838
          
          # Ensure container is restarted to apply settings
          echo "Restarting web app to apply configuration..."
          az webapp restart --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG
          
          # Display the web app URL
          WEBAPP_URL=$(az webapp show --name ${{ env.WEBAPP_NAME }} --resource-group RenoPilotWebAppRG --query "defaultHostName" -o tsv)
          echo "Web app deployed successfully at: https://$WEBAPP_URL"
          echo "Shiny app should be accessible at: https://$WEBAPP_URL"

    - name: Configure Network Security Rules
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Create rule collections for the region-specific firewalls
          echo "Creating firewall rule collections..."
          
          # Check if SQL traffic rule collection already exists
          if ! az network firewall network-rule collection show --name sqltraffic --firewall-name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            az network firewall network-rule create \
              --collection-name sqltraffic \
              --name SQLRule \
              --destination-ports 1433 \
              --firewall-name ${{ env.PRIVATE_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses 10.1.1.0/24 \
              --destination-addresses "*" \
              --action Allow \
              --priority 100 || echo "SQL rule creation failed, but continuing"
          else
            echo "SQL traffic rule collection already exists."
          fi
          
          # Check if Docker registry rule collection already exists
          if ! az network firewall network-rule collection show --name dockertraffic --firewall-name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Creating Docker registry rule collection..."
            az network firewall network-rule create \
              --collection-name dockertraffic \
              --name DockerRule \
              --destination-ports 5000 \
              --firewall-name ${{ env.PRIVATE_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses 10.1.1.0/24 \
              --destination-addresses 10.1.2.0/24 \
              --action Allow \
              --priority 200 || echo "Docker rule creation failed, but continuing"
          else
            echo "Docker registry rule collection already exists."
          fi
          
          # Check if HTTP rule collection already exists
          if ! az network firewall network-rule collection show --name webtraffic --firewall-name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Creating HTTP rule collection..."
            az network firewall network-rule create \
              --collection-name webtraffic \
              --name HTTPRule \
              --destination-ports 80 \
              --firewall-name ${{ env.PUBLIC_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses "*" \
              --destination-addresses 10.1.1.0/24 \
              --action Allow \
              --priority 300 || echo "HTTP rule creation failed, but continuing"
          else
            echo "HTTP rule collection already exists."
          fi
          
          # Check if Shiny rule collection already exists
          if ! az network firewall network-rule collection show --name shinytraffic --firewall-name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotWebAppRG &>/dev/null; then
            echo "Creating Shiny rule collection..."
            az network firewall network-rule create \
              --collection-name shinytraffic \
              --name ShinyRule \
              --destination-ports 3838 \
              --firewall-name ${{ env.PUBLIC_FW_NAME }} \
              --protocols TCP \
              --resource-group RenoPilotWebAppRG \
              --source-addresses "*" \
              --destination-addresses 10.1.1.0/24 \
              --action Allow \
              --priority 400 || echo "Shiny rule creation failed, but continuing"
          else
            echo "Shiny rule collection already exists."
          fi
          
          # Configure Azure SQL Server firewall rules
          echo "Configuring Azure SQL Server firewall rules..."
          
          # First check if SQL server exists
          if az sql server show --name shiny --resource-group RenoPilotWebAppRG &>/dev/null; then
            SUBNET_ADDRESS_PREFIX=$(az network vnet subnet show --resource-group RenoPilotWebAppRG --vnet-name ${{ env.VNET_NAME }} --name ${{ env.PUBLIC_SUBNET_NAME }} --query addressPrefix -o tsv)
            
            # Only try to create the firewall rule if the subnet was found
            if [ -n "$SUBNET_ADDRESS_PREFIX" ]; then
              echo "Found subnet prefix: $SUBNET_ADDRESS_PREFIX"
              # Check if firewall rule already exists
              if az sql server firewall-rule show --name "AllowWebAppSubnet" --server shiny --resource-group RenoPilotWebAppRG &>/dev/null; then
                echo "SQL firewall rule 'AllowWebAppSubnet' already exists."
              else
                echo "Creating SQL firewall rule 'AllowWebAppSubnet'..."
                az sql server firewall-rule create \
                  --resource-group RenoPilotWebAppRG \
                  --server shiny \
                  --name "AllowWebAppSubnet" \
                  --start-ip-address ${SUBNET_ADDRESS_PREFIX%/*} \
                  --end-ip-address 255.255.255.255 || echo "SQL server firewall rule creation failed, but continuing"
              fi
            else
              echo "Warning: Could not find subnet prefix. Skipping SQL firewall rule creation."
            fi
          else
            echo "SQL server 'shiny' not found. Skipping firewall rule creation."
          fi