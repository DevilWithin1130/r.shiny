name: RenoPilot Container Instance CI/CD

on: 
  push:
    branches: [main]
    paths-ignore:
    - '.github/workflows/webapp-ci-cd.yaml'
  pull_request:
    branches: [main]
    paths-ignore:
    - '.github/workflows/webapp-ci-cd.yaml'
  workflow_dispatch:
    inputs:
      preferred_region:
        description: 'Preferred Azure Region (leave empty for auto-selection)'
        required: false
        default: ''

jobs:
  test-app:
    runs-on: ubuntu-latest
    name: Test R Shiny App
    
    env:
      GITHUB_PAT: ${{ secrets.RENOPILOT_TOKEN }}
      R_KEEP_PKG_SOURCE: yes

    steps:
      - name: Checkout Code Base
        uses: actions/checkout@v3

      - name: Set up R Environment
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: release
          use-public-rspm: true

      - name: Install Dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: shinytest2

      - name: Define Environment Variables
        run: |
          echo Environment="Github" >> ~/.Renviron
          echo Driver="ODBC Driver 18 for SQL Server" >> ~/.Renviron
          echo Server="shiny.database.windows.net" >> ~/.Renviron
          echo Database="Shiny" >> ~/.Renviron
          echo UID="shiny" >> ~/.Renviron
          echo PWD="${{ secrets.DB_PASSWORD }}" >> ~/.Renviron
        shell: bash

      - name: Run Tests
        uses: rstudio/shinytest2/actions/test-app@v1
        with:
          path: "."

  deploy-infrastructure:
    needs: test-app
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@main

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Register Required Resource Providers
      uses: azure/cli@v1
      with:
        inlineScript: |
          echo "Registering Azure resource providers required for RenoPilot Container infrastructure..."
          az provider register --namespace Microsoft.ContainerInstance
          az provider register --namespace Microsoft.Network
          az provider register --namespace Microsoft.ContainerRegistry
          
          echo "Waiting for RenoPilot required Azure service registrations to complete..."
          for provider in Microsoft.ContainerInstance Microsoft.Network Microsoft.ContainerRegistry; do
            state=$(az provider show -n $provider --query registrationState -o tsv)
            echo "RenoPilot Azure dependency: $provider registration state: $state"
            if [ "$state" != "Registered" ]; then
              echo "Waiting for $provider to complete registration..."
              for i in {1..12}; do
                sleep 10
                state=$(az provider show -n $provider --query registrationState -o tsv)
                echo "$provider registration state: $state"
                if [ "$state" == "Registered" ]; then
                  break
                fi
                if [ $i -eq 12 ] && [ "$state" != "Registered" ]; then
                  echo "Warning: $provider registration taking longer than expected. Continuing anyway."
                fi
              done
            fi
          done
    
    - name: Check Existing Infrastructure
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Check if a region was specified in workflow dispatch
          PREFERRED_REGION="${{ github.event.inputs.preferred_region }}"
          
          # Primary regions in order of preference (Australia first, then global fallbacks)
          REGIONS=("australiaeast" "australiasoutheast" "australiacentral" "australiacentral2")
          
          # Global fallback regions if Australian regions are not available
          FALLBACK_REGIONS=("eastus" "westus2" "centralus" "westeurope" "northeurope" "southeastasia" "eastasia")
          
          LOCATION=""
          
          # If a region was specified via workflow_dispatch, try to use it
          if [ -n "$PREFERRED_REGION" ]; then
            echo "Using manually specified region: $PREFERRED_REGION"
            if az container list-skus --location $PREFERRED_REGION --output none 2>/dev/null; then
              LOCATION=$PREFERRED_REGION
              echo "Manually specified region $PREFERRED_REGION is available."
            else
              echo "WARNING: Manually specified region $PREFERRED_REGION is not available for Container Instances."
              echo "Will attempt to find an available region automatically."
            fi
          fi
          
          # Check if Resource Group exists
          RG_EXISTS=$(az group exists --name RenoPilotContainerRG)
          
          if [ "$RG_EXISTS" = "true" ]; then
            echo "Resource Group already exists."
            
            # If no manually specified region or it was unavailable
            if [ -z "$LOCATION" ]; then
              # If resource group exists, check if we already have resources deployed
              EXISTING_CONTAINERS=$(az container list --resource-group RenoPilotContainerRG --query "[].{name:name, location:location}" -o json)
              
              # If we have existing containers, use their location
              if [ -n "$EXISTING_CONTAINERS" ] && [ "$EXISTING_CONTAINERS" != "[]" ]; then
                EXISTING_LOCATION=$(echo $EXISTING_CONTAINERS | jq -r '.[0].location')
                echo "Using existing resources location: $EXISTING_LOCATION"
                LOCATION=$EXISTING_LOCATION
              fi
            fi
            
            # If no valid location found yet, check all regions
            if [ -z "$LOCATION" ]; then
              echo "Searching for available region..."
              
              # First check Australian regions (preferred)
              for region in "${REGIONS[@]}"; do
                echo "Checking Australian region availability: $region"
                if az container list-skus --location $region --output none 2>/dev/null; then
                  echo "Found available Australian region: $region"
                  LOCATION=$region
                  break
                else
                  echo "Australian region $region not available for Container Instances."
                fi
              done
              
              # If no Australian regions available, try global fallbacks
              if [ -z "$LOCATION" ]; then
                echo "No Australian regions available. Checking global fallback regions..."
                for region in "${FALLBACK_REGIONS[@]}"; do
                  echo "Checking global region availability: $region"
                  if az container list-skus --location $region --output none 2>/dev/null; then
                    echo "Found available global region: $region"
                    LOCATION=$region
                    break
                  else
                    echo "Global region $region not available for Container Instances."
                  fi
                done
              fi
            fi
          else
            echo "Resource Group does not exist. Creating in an available region."
            
            # Try Australian regions first (if no manually specified location)
            if [ -z "$LOCATION" ]; then
              for region in "${REGIONS[@]}"; do
                echo "Checking Australian region availability: $region"
                if az container list-skus --location $region --output none 2>/dev/null; then
                  echo "Found available Australian region: $region"
                  LOCATION=$region
                  break
                else
                  echo "Australian region $region not available for Container Instances."
                fi
              done
              
              # If no Australian regions available, try global fallbacks
              if [ -z "$LOCATION" ]; then
                echo "No Australian regions available. Checking global fallback regions..."
                for region in "${FALLBACK_REGIONS[@]}"; do
                  echo "Checking global region availability: $region"
                  if az container list-skus --location $region --output none 2>/dev/null; then
                    echo "Found available global region: $region"
                    LOCATION=$region
                    break
                  else
                    echo "Global region $region not available for Container Instances."
                  fi
                done
              fi
            fi
            
            # Create resource group in chosen region
            if [ -n "$LOCATION" ]; then
              az group create --name RenoPilotContainerRG --location $LOCATION
            fi
          fi
          
          # If still no region was found
          if [ -z "$LOCATION" ]; then
            echo "ERROR: Could not find any available region for Container Instances."
            echo "Please check Azure service availability or contact Azure support."
            exit 1
          fi
          
          echo "Using region: $LOCATION"
          
          # Store location for use in later steps
          echo "AZURE_LOCATION=$LOCATION" >> $GITHUB_ENV
          
          # Generate a timestamp for unique resource names
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV

    - name: Clean Existing Infrastructure
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          echo "Starting infrastructure cleanup in region: $LOCATION"
          
          # Define resource naming patterns
          CONTAINER_NAME="renopilot-container-$LOCATION"
          VNET_NAME="renopilot-container-vpc-$LOCATION"
          SUBNET_NAME="ContainerSubnet-$LOCATION"
          PUBLIC_FW_NAME="container-publicfw-$LOCATION"
          PRIVATE_FW_NAME="container-privatefw-$LOCATION"
          NSG_NAME="container-nsg-$LOCATION"
          ACR_NAME="renopilot${LOCATION}reg"
          
          # Store names for later steps
          echo "VNET_NAME=$VNET_NAME" >> $GITHUB_ENV
          echo "SUBNET_NAME=$SUBNET_NAME" >> $GITHUB_ENV
          echo "PUBLIC_FW_NAME=$PUBLIC_FW_NAME" >> $GITHUB_ENV
          echo "PRIVATE_FW_NAME=$PRIVATE_FW_NAME" >> $GITHUB_ENV
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV
          
          # 1. Delete Container Instances
          echo "Checking for existing container instances..."
          if az container show --name $CONTAINER_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Deleting container instance: $CONTAINER_NAME"
            az container delete --name $CONTAINER_NAME --resource-group RenoPilotContainerRG --yes
            echo "Waiting for container deletion to complete..."
            sleep 30
          else
            echo "No existing container instance found."
          fi
          
          # 2. Delete Network Security Group Rules first
          echo "Checking for existing NSG rules..."
          if az network nsg show --name $NSG_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            if az network nsg rule show --name AllowShinyInbound --nsg-name $NSG_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
              echo "Deleting NSG rule: AllowShinyInbound"
              az network nsg rule delete --name AllowShinyInbound --nsg-name $NSG_NAME --resource-group RenoPilotContainerRG
            fi
          fi
          
          # 3. Remove NSG from subnet if exists
          echo "Checking if subnet has NSG association..."
          if az network vnet subnet show --name $SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Removing NSG association from subnet..."
            az network vnet subnet update --name $SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotContainerRG --network-security-group "" || echo "No NSG to remove or error removing NSG from subnet."
          fi
          
          # 4. Delete Network Security Group
          echo "Checking for existing NSG..."
          if az network nsg show --name $NSG_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Deleting NSG: $NSG_NAME"
            az network nsg delete --name $NSG_NAME --resource-group RenoPilotContainerRG
          else
            echo "No existing NSG found."
          fi
          
          # 5. Delete Firewall Rule Collections
          echo "Checking for existing firewall rule collections..."
          if az network firewall show --name $PRIVATE_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            for collection in sqltraffic dockertraffic; do
              if az network firewall network-rule collection show --name $collection --firewall-name $PRIVATE_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
                echo "Deleting rule collection: $collection"
                az network firewall network-rule collection delete --name $collection --firewall-name $PRIVATE_FW_NAME --resource-group RenoPilotContainerRG
              fi
            done
          fi
          
          if az network firewall show --name $PUBLIC_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            for collection in webtraffic shinytraffic; do
              if az network firewall network-rule collection show --name $collection --firewall-name $PUBLIC_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
                echo "Deleting rule collection: $collection"
                az network firewall network-rule collection delete --name $collection --firewall-name $PUBLIC_FW_NAME --resource-group RenoPilotContainerRG
              fi
            done
          fi
          
          # 6. Delete Firewalls
          echo "Checking for existing firewalls..."
          if az network firewall show --name $PRIVATE_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Deleting private firewall: $PRIVATE_FW_NAME"
            az network firewall delete --name $PRIVATE_FW_NAME --resource-group RenoPilotContainerRG
          else
            echo "No existing private firewall found."
          fi
          
          if az network firewall show --name $PUBLIC_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Deleting public firewall: $PUBLIC_FW_NAME"
            az network firewall delete --name $PUBLIC_FW_NAME --resource-group RenoPilotContainerRG
          else
            echo "No existing public firewall found."
          fi
          
          # 7. Delete Subnet
          echo "Checking for existing subnet..."
          if az network vnet subnet show --name $SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Deleting subnet: $SUBNET_NAME"
            az network vnet subnet delete --name $SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotContainerRG
            echo "Waiting for subnet deletion to complete..."
            sleep 30
          else
            echo "No existing subnet found."
          fi
          
          # 8. Delete Virtual Network
          echo "Checking for existing VNet..."
          if az network vnet show --name $VNET_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Deleting VNet: $VNET_NAME"
            az network vnet delete --name $VNET_NAME --resource-group RenoPilotContainerRG
            echo "Waiting for VNet deletion to complete..."
            sleep 30
          else
            echo "No existing VNet found."
          fi
          
          # 9. We'll keep ACR to maintain Docker images, just verify it exists or will be created
          echo "Checking ACR..."
          if az acr show --name $ACR_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Container Registry exists: $ACR_NAME - will be kept to preserve images"
          else
            echo "Container Registry does not exist, will be created in later steps."
          fi
          
          echo "Cleanup completed. Ready for fresh infrastructure deployment."

    - name: Deploy Container Registry
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          # Use a unique ACR name that includes location (ACR names must be globally unique)
          ACR_NAME="${{ env.ACR_NAME }}"
          
          # Check if ACR already exists
          if az acr show --name $ACR_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Container Registry '$ACR_NAME' already exists. Skipping creation."
          else
            echo "Creating Container Registry '$ACR_NAME'..."
            az acr create \
              --resource-group RenoPilotContainerRG \
              --name $ACR_NAME \
              --sku Standard \
              --location $LOCATION \
              --admin-enabled true
          fi
          
          # Retrieve and store registry credentials securely in GitHub environment
          ACR_LOGIN_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)
          ACR_USERNAME=$(az acr credential show -n $ACR_NAME --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show -n $ACR_NAME --query "passwords[0].value" -o tsv)
          
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
          echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV
          # Add mask to hide sensitive output in logs
          echo "::add-mask::$ACR_PASSWORD"

    - name: Check if Docker image exists
      id: check-image
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          ACR_NAME="renopilot${LOCATION}reg"
          
          # Get the latest commit SHA from the RenoPilot.Container.2025 repository
          echo "Fetching latest commit SHA from RenoPilot/RenoPilot.Container.2025.git..."
          CONTAINER_REPO_SHA=$(curl -s https://api.github.com/repos/RenoPilot/RenoPilot.Container.2025/commits/main | jq -r .sha)
          
          # In case of API rate limiting or other errors, provide a fallback
          if [ -z "$CONTAINER_REPO_SHA" ] || [ "$CONTAINER_REPO_SHA" == "null" ]; then
            echo "Failed to fetch SHA from remote repository. Using current commit SHA as fallback."
            CONTAINER_REPO_SHA="${{ github.sha }}"
          else
            echo "Using RenoPilot.Container.2025 repository SHA: $CONTAINER_REPO_SHA"
          fi
          
          # Store the SHA for later use
          echo "CONTAINER_REPO_SHA=$CONTAINER_REPO_SHA" >> $GITHUB_ENV
          
          IMAGE_NAME="renopilot-container"
          
          # Check if the image with the specific tag already exists in ACR
          echo "Checking if image $IMAGE_NAME:$CONTAINER_REPO_SHA already exists in ACR..."
          
          # Using az acr repository show to check if image exists
          if az acr repository show --name $ACR_NAME --image "$IMAGE_NAME:$CONTAINER_REPO_SHA" &>/dev/null; then
            echo "Image $IMAGE_NAME:$CONTAINER_REPO_SHA already exists in ACR. Skipping build and push."
            echo "IMAGE_EXISTS=true" >> $GITHUB_ENV
            echo "exists=true" >> $GITHUB_OUTPUT  # Updated to current GitHub Actions syntax
          else
            echo "Image $IMAGE_NAME:$CONTAINER_REPO_SHA does not exist in ACR. Will build and push."
            echo "IMAGE_EXISTS=false" >> $GITHUB_ENV
            echo "exists=false" >> $GITHUB_OUTPUT  # Updated to current GitHub Actions syntax
          fi

    - name: Build and push image
      if: env.IMAGE_EXISTS != 'true'
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ env.ACR_USERNAME }}
        password: ${{ env.ACR_PASSWORD }}
    - run: |
        if [ "${{ env.IMAGE_EXISTS }}" != "true" ]; then
          echo "Building and pushing new Docker image from RenoPilot.Container.2025 repository..."
          
          # Clone the repository
          git clone https://github.com/RenoPilot/RenoPilot.Container.2025.git temp-container-repo
          cd temp-container-repo
          
          # Build the Docker image
          docker build -f containerResources/dockerfile . -t ${{ env.ACR_LOGIN_SERVER }}/renopilot-container:${{ env.CONTAINER_REPO_SHA }}
          
          # Push the image to ACR
          docker push ${{ env.ACR_LOGIN_SERVER }}/renopilot-container:${{ env.CONTAINER_REPO_SHA }}
          
          # Clean up
          cd .. 
          rm -rf temp-container-repo
        else
          echo "Skipping Docker build and push as image already exists."
        fi

    - name: Create Virtual Network and Subnet
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          
          # Create VNet with region-specific name
          VNET_NAME="renopilot-container-vpc-$LOCATION"
          
          # Check if VNet already exists
          if az network vnet show --name $VNET_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "VNet '$VNET_NAME' already exists. Skipping creation."
          else
            echo "Creating VNet '$VNET_NAME'..."
            az network vnet create \
              --name $VNET_NAME \
              --resource-group RenoPilotContainerRG \
              --location $LOCATION \
              --address-prefix 10.2.0.0/16
              
            # Add delay to ensure VNet is fully provisioned
            sleep 10
          fi
          
          # Store VNet name for later steps
          echo "VNET_NAME=$VNET_NAME" >> $GITHUB_ENV
          
          # Check if subnet already exists
          SUBNET_NAME="ContainerSubnet-$LOCATION"
          if az network vnet subnet show --name $SUBNET_NAME --vnet-name $VNET_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Subnet '$SUBNET_NAME' already exists. Skipping creation."
          else
            echo "Creating Subnet '$SUBNET_NAME'..."
            az network vnet subnet create \
              --name $SUBNET_NAME \
              --vnet-name $VNET_NAME \
              --resource-group RenoPilotContainerRG \
              --address-prefix 10.2.1.0/24 \
              --delegations Microsoft.ContainerInstance/containerGroups
              
            # Add delay to ensure subnet is fully provisioned
            sleep 10
          fi
          
          # Store subnet name for later steps
          echo "SUBNET_NAME=$SUBNET_NAME" >> $GITHUB_ENV
          
    - name: Deploy Firewalls
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          
          # Create Public Firewall with region-specific name
          PUBLIC_FW_NAME="container-publicfw-$LOCATION"
          
          # Check if public firewall already exists
          if az network firewall show --name $PUBLIC_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Public Firewall '$PUBLIC_FW_NAME' already exists. Skipping creation."
          else
            echo "Creating Public Firewall '$PUBLIC_FW_NAME'..."
            az network firewall create \
              --name $PUBLIC_FW_NAME \
              --resource-group RenoPilotContainerRG \
              --location $LOCATION
          fi
          
          # Store firewall name for later steps
          echo "PUBLIC_FW_NAME=$PUBLIC_FW_NAME" >> $GITHUB_ENV
          
          # Create Private Firewall with region-specific name
          PRIVATE_FW_NAME="container-privatefw-$LOCATION"
          
          # Check if private firewall already exists
          if az network firewall show --name $PRIVATE_FW_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Private Firewall '$PRIVATE_FW_NAME' already exists. Skipping creation."
          else
            echo "Creating Private Firewall '$PRIVATE_FW_NAME'..."
            az network firewall create \
              --name $PRIVATE_FW_NAME \
              --resource-group RenoPilotContainerRG \
              --location $LOCATION
          fi
          
          # Store firewall name for later steps
          echo "PRIVATE_FW_NAME=$PRIVATE_FW_NAME" >> $GITHUB_ENV

    - name: Deploy Container Instance with SKU fallback
      uses: azure/cli@v1
      with:
        inlineScript: |
          LOCATION="${{ env.AZURE_LOCATION }}"
          CONTAINER_NAME="renopilot-container-$LOCATION"
          
          # Check if Container Instance already exists
          if az container show --name $CONTAINER_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Container Instance '$CONTAINER_NAME' already exists. Updating with new image..."
            
            # Update existing container with new image
            az container create \
              --name $CONTAINER_NAME \
              --resource-group RenoPilotContainerRG \
              --image ${{ env.ACR_LOGIN_SERVER }}/renopilot-container:${{ env.CONTAINER_REPO_SHA || github.sha }} \
              --registry-login-server ${{ env.ACR_LOGIN_SERVER }} \
              --registry-username ${{ env.ACR_USERNAME }} \
              --registry-password ${{ env.ACR_PASSWORD }} \
              --os-type Linux \
              --replace
          else
            echo "Creating new Container Instance '$CONTAINER_NAME'..."
            
            # Try different CPU/Memory configurations if facing quota issues
            CONFIGS=(
              "2 4"    # 2 CPU cores, 4GB memory
              "1 2"    # 1 CPU core, 2GB memory
              "0.5 1"  # 0.5 CPU cores, 1GB memory
            )
            
            MAX_RETRIES=3
            CREATION_SUCCESS=false
            
            # Try different configurations with retries
            for CONFIG in "${CONFIGS[@]}"; do
              read -r CPU MEMORY <<< "$CONFIG"
              echo "Attempting to create Container Instance with: $CPU CPU, $MEMORY GB memory"
              
              for ((i=1; i<=MAX_RETRIES; i++)); do
                echo "Attempt $i of $MAX_RETRIES..."
                
                if az container create \
                  --name $CONTAINER_NAME \
                  --resource-group RenoPilotContainerRG \
                  --image ${{ env.ACR_LOGIN_SERVER }}/renopilot-container:${{ github.sha }} \
                  --registry-login-server ${{ env.ACR_LOGIN_SERVER }} \
                  --registry-username ${{ env.ACR_USERNAME }} \
                  --registry-password ${{ env.ACR_PASSWORD }} \
                  --os-type Linux \
                  --cpu $CPU \
                  --memory $MEMORY \
                  --ports 3838 \
                  --ip-address Public \
                  --dns-name-label ${CONTAINER_NAME}-${LOCATION} \
                  --environment-variables \
                    DB_SERVER=shiny.database.windows.net \
                    DB_NAME=Shiny \
                    DB_USER=shiny \
                    DB_DRIVER="ODBC Driver 18 for SQL Server" \
                    DB_PORT=1433 \
                  --secure-environment-variables \
                    DB_PASSWORD="${{ secrets.DB_PASSWORD }}" \
                  --location $LOCATION; then
                  
                  echo "Container Instance created successfully with $CPU CPU, $MEMORY GB memory!"
                  echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV
                  echo "CONTAINER_CPU=$CPU" >> $GITHUB_ENV
                  echo "CONTAINER_MEMORY=$MEMORY" >> $GITHUB_ENV
                  CREATION_SUCCESS=true
                  break 2  # Break out of both loops
                else
                  echo "Failed to create Container Instance with $CPU CPU, $MEMORY GB memory. Waiting before retry..."
                  if [ $i -lt $MAX_RETRIES ]; then
                    # Exponential backoff - wait longer with each retry
                    SLEEP_TIME=$((20 * i))
                    echo "Waiting for $SLEEP_TIME seconds before next attempt..."
                    sleep $SLEEP_TIME
                  fi
                fi
              done
            done
            
            # Check if we succeeded with any configuration
            if [ "$CREATION_SUCCESS" != "true" ]; then
              echo "ERROR: All attempts to create Container Instance failed."
              echo "Please check your Azure subscription quota limits and try again."
              exit 1
            fi
          fi
          
          # Display the container IP and URL
          echo "Getting Container Instance details..."
          CONTAINER_IP=$(az container show --name $CONTAINER_NAME --resource-group RenoPilotContainerRG --query ipAddress.ip --output tsv 2>/dev/null || echo "IP not available")
          if [ "$CONTAINER_IP" != "IP not available" ] && [ -n "$CONTAINER_IP" ]; then
            echo "Container deployed successfully at IP: $CONTAINER_IP"
            echo "Shiny app should be accessible at: http://$CONTAINER_IP:3838"
          else
            echo "Container IP address not available yet. It may take a few minutes to initialize."

    - name: Configure Network Security Rules
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Create/update Network Security Group with region-specific name
          LOCATION="${{ env.AZURE_LOCATION }}"
          NSG_NAME="container-nsg-$LOCATION"
          
          # Check if NSG already exists
          if az network nsg show --name $NSG_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Network Security Group '$NSG_NAME' already exists."
          else
            echo "Creating Network Security Group '$NSG_NAME'..."
            az network nsg create \
              --name $NSG_NAME \
              --resource-group RenoPilotContainerRG \
              --location $LOCATION
          fi
          
          # Check if the Shiny inbound rule exists before creating it
          if az network nsg rule show --name AllowShinyInbound --nsg-name $NSG_NAME --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Shiny inbound rule already exists."
          else
            echo "Adding inbound security rule for Shiny port 3838..."
            az network nsg rule create \
              --name AllowShinyInbound \
              --nsg-name $NSG_NAME \
              --resource-group RenoPilotContainerRG \
              --priority 100 \
              --direction Inbound \
              --access Allow \
              --protocol Tcp \
              --source-address-prefixes "*" \
              --source-port-ranges "*" \
              --destination-address-prefixes "*" \
              --destination-port-ranges 3838 \
              --description "Allow Shiny Server traffic on port 3838" || echo "Rule creation failed, but continuing."
          fi
          
          # Check if the subnet exists before applying NSG
          if az network vnet subnet show --name ${{ env.SUBNET_NAME }} --vnet-name ${{ env.VNET_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
            # Apply NSG to the subnet
            echo "Applying NSG to subnet..."
            az network vnet subnet update \
              --name ${{ env.SUBNET_NAME }} \
              --vnet-name ${{ env.VNET_NAME }} \
              --resource-group RenoPilotContainerRG \
              --network-security-group $NSG_NAME
          else
            echo "Subnet ${{ env.SUBNET_NAME }} does not exist. Skipping NSG application."
          fi
          
          # Configure Azure SQL Server firewall rules
          echo "Configuring Azure SQL Server firewall rules..."
          # First check if SQL server exists
          if az sql server show --name shiny --resource-group RenoPilotContainerRG &>/dev/null; then
            SUBNET_ADDRESS_PREFIX=$(az network vnet subnet show --resource-group RenoPilotContainerRG --vnet-name ${{ env.VNET_NAME }} --name ${{ env.SUBNET_NAME }} --query addressPrefix -o tsv 2>/dev/null)
            
            # Only try to create the firewall rule if the subnet was found
            if [ -n "$SUBNET_ADDRESS_PREFIX" ]; then
              echo "Found subnet prefix: $SUBNET_ADDRESS_PREFIX"
              # Check if firewall rule already exists
              if az sql server firewall-rule show --name "AllowContainerSubnet" --server shiny --resource-group RenoPilotContainerRG &>/dev/null; then
                echo "SQL firewall rule 'AllowContainerSubnet' already exists."
              else
                echo "Creating SQL firewall rule 'AllowContainerSubnet'..."
                az sql server firewall-rule create \
                  --resource-group RenoPilotContainerRG \
                  --server shiny \
                  --name "AllowContainerSubnet" \
                  --start-ip-address ${SUBNET_ADDRESS_PREFIX%/*} \
                  --end-ip-address 255.255.255.255 || echo "SQL server firewall rule creation failed, but continuing"
              fi
            else
              echo "Warning: Could not find subnet prefix. Skipping SQL firewall rule creation."
            fi
          else
            echo "SQL server 'shiny' not found. Skipping firewall rule creation."
          fi

    - name: Create Firewall Rule Collections
      uses: azure/cli@v1
      with:
        inlineScript: |
          # Create rule collections for the region-specific firewalls similar to webapp-ci-cd
          LOCATION="${{ env.AZURE_LOCATION }}"
          
          # Create SQL traffic rule if the firewall exists
          if az network firewall show --name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Creating SQL traffic rule collection..."
            
            # Check if collection exists first to avoid errors
            if ! az network firewall network-rule collection show --name sqltraffic --firewall-name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
              az network firewall network-rule create \
                --collection-name sqltraffic \
                --name SQLRule \
                --destination-ports 1433 \
                --firewall-name ${{ env.PRIVATE_FW_NAME }} \
                --protocols TCP \
                --resource-group RenoPilotContainerRG \
                --source-addresses 10.2.1.0/24 \
                --destination-addresses "*" \
                --action Allow \
                --priority 100 || echo "Failed to create SQL rule, but continuing"
            else
              # Check if rule exists in collection
              echo "SQL traffic rule collection already exists. Checking if rule exists..."
              # Continue without error since the collection already exists, which is fine
            fi
          else
            echo "Private firewall not found. Skipping SQL rule collection creation."
          fi
          
          # Create Docker registry rule if the firewall exists
          if az network firewall show --name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Creating Docker registry rule collection..."
            
            # Check if collection exists first to avoid errors
            if ! az network firewall network-rule collection show --name dockertraffic --firewall-name ${{ env.PRIVATE_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
              az network firewall network-rule create \
                --collection-name dockertraffic \
                --name DockerRule \
                --destination-ports 5000 \
                --firewall-name ${{ env.PRIVATE_FW_NAME }} \
                --protocols TCP \
                --resource-group RenoPilotContainerRG \
                --source-addresses 10.2.1.0/24 \
                --destination-addresses "*" \
                --action Allow \
                --priority 200 || echo "Failed to create Docker rule, but continuing"
            else
              echo "Docker traffic rule collection already exists."
            fi
          else
            echo "Private firewall not found. Skipping Docker rule collection creation."
          fi
          
          # Create HTTP rule if the firewall exists
          if az network firewall show --name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Creating HTTP rule collection..."
            
            # Check if collection exists first to avoid errors
            if ! az network firewall network-rule collection show --name webtraffic --firewall-name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
              az network firewall network-rule create \
                --collection-name webtraffic \
                --name HTTPRule \
                --destination-ports 80 \
                --firewall-name ${{ env.PUBLIC_FW_NAME }} \
                --protocols TCP \
                --resource-group RenoPilotContainerRG \
                --source-addresses "*" \
                --destination-addresses 10.2.1.0/24 \
                --action Allow \
                --priority 300 || echo "Failed to create HTTP rule, but continuing"
            else
              echo "HTTP traffic rule collection already exists."
            fi
          else
            echo "Public firewall not found. Skipping HTTP rule collection creation."
          fi
          
          # Create Shiny rule if the firewall exists
          if az network firewall show --name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
            echo "Creating Shiny rule collection..."
            
            # Check if collection exists first to avoid errors
            if ! az network firewall network-rule collection show --name shinytraffic --firewall-name ${{ env.PUBLIC_FW_NAME }} --resource-group RenoPilotContainerRG &>/dev/null; then
              az network firewall network-rule create \
                --collection-name shinytraffic \
                --name ShinyRule \
                --destination-ports 3838 \
                --firewall-name ${{ env.PUBLIC_FW_NAME }} \
                --protocols TCP \
                --resource-group RenoPilotContainerRG \
                --source-addresses "*" \
                --destination-addresses 10.2.1.0/24 \
                --action Allow \
                --priority 400 || echo "Failed to create Shiny rule, but continuing"
            else
              echo "Shiny traffic rule collection already exists."
            fi
          else
            echo "Public firewall not found. Skipping Shiny rule collection creation."
          fi